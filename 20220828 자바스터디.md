# 컬렉션이란?

- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미한다.
- 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것이다.

## 자바에서의 자료구조 유형

1. List형 : 순서가 있는 목록
2. Set형 : 순서가 중요하지 않은 목록
3. Queue형 : 먼저 들어온 것이 먼저 나감
4. Map형 : 키-값의 형태로 저장

## 자바 컬렉션

1. List 인터페이스 : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
- 구현클래스 : ArrayList, LinkedList, Stack, Vector 등
- ex) 대기자 명단

2. Set 인터페이스 : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
- 구현클래스 : HashSet, TreeSet 등
- ex) 집합

3. Map 인터페이스 : 키와 값의 쌍으로 이루어진 데이터의 집합, 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
- 구현클래스 : HashMap, TreeMap, Hashtable, Properties 등
- ex) 우편번호


# ArrayList, LinkedList 성능비교

![ArrayListLinkedList 속도비교](https://user-images.githubusercontent.com/83864280/187054555-05d38277-e757-44a4-a6da-90e1809be3d7.png)


## ArrayList

- 기본적으로 배열을 사용한다. 
- 배열과 다르게 메모리 크기를 지정하지 않고 동적으로 값을 삽입, 삭제 할 수 있다.
- 조회 : 인덱스를 가지고 있기 때문에 해당 인덱스의 데이터를 한번에 가져올 수 있다.
- 삽입, 삭제시 비효율적이다.


## LinkedList

- 양방향 연결리스트다.
- 조회 : 순차적 접근이므로 검색 속도가 느리다.
- 삽입, 삭제 : 데이터를 삽입, 삭제시 가리키는 주소값만 변경하면 되므로 상당히 효율적이다.

- 참고 : https://dev-coco.tistory.com/19


# 프로그램이란?

- 어떤 작업을 위해 실행할 수 있는 파일

# 프로세스란?

- 컴퓨터에서 연속적으로 실행되고 컴퓨터 프로그램
- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- 프로세스는 각각 독립된 메모리 영역(code, data, stack, heap)을 갖는다.
- 기본적으로 프로세스 1개당 최소 1개의 쓰레드를 가진다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 다른 프로세스의 자원에 접근할 수 없다.
- 프로세스가 다른 프로세스에 접근하려면 IPC를 사용해야 한다.

## IPC란?
- 프로세스 간에 통신하는 방법을 의미한다.
- 참고 : https://velog.io/@yanghl98/OS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-IPC%EB%9E%80

## 프로그램이 프로세스가 되면서 발생하는 일

1. 프로세스가 필요로 하는 재료들이 메모리에 올라가야 한다.
- code, data, stack, heap이 메모리 공간을 확보한다.

2. 해당 프로세스에 대한 정보를 담고 있는 pcb 블록이 생성된다.


## 할당받는 시스템 자원의 예

- cpu 시간
- 운영되기 위해 필요한 주소공간
- code, data, stack, heap의 구조로 되어 있는 독립된 메모리 영역

1. code : 실행 명령을 포함하는 코드들
2. data : static 변수 혹은 global 변수
3. stack : 지역변수, 매개변수, 반환값 등등 일시적인 데이터
4. heap : 동적 메모리 영역


## context switching

- 작업의 주체가 현재 Context를 잠시 중단하고 다른 Context를 실행하는 것을 Context Switching이라 한다.

- 참고 자료: https://velog.io/@curiosity806/Context-Switching%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-process%EC%99%80-thread

# 쓰레드란?

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 쓰레드는 프로세스 내에서 code, data, heap 영역은 공유하고 stack영역만  따로 할당받는다.
- 같은 프로세스 내에 있는 쓰레드들은 자원을 공유하면서 실행한다.
- 같은 프로세스 안에 있는 쓰레드가 프로세스 자원을 변경하면 이웃 쓰레드는 변경 결과를 즉시 볼 수 있다.


# 멀티프로세스

- 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것이다

### 장점
1. 여러 개의 하위 프로세스 중 하나에 문제가 발생하면 그 하위 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.

### 단점
1. 프로세스는 각각 독립되어 있어 공유하는 메모리가 없어 캐시의 정보를 모두 리셋하고 다시 불러와야 하므로 비용이 많이 든다.
2. 프로세스 사이에 복잡한 통신 기법을 사용해야한다.

### 예시 : 크롬

# 멀티쓰레드
- 하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것이다.

### 장점:
1. 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
2. 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
3. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.

### 단점:
1. 디버깅이 까다롭다.
2. 다른 프로세스에서 스레드를 제어할 수 없다.
3. 멀티 쓰레드의 공유 자원 공유의 문제가 발생할 수 있다.(동기화)
4. 하나의 쓰레드에 문제가 생기면 프로세스 전체가 영향을 받는다. 


### 예시: 인터넷 익스플로어

- 참고 : https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html
- 참고 : https://jeong-pro.tistory.com/93
- 참고 : https://www.youtube.com/watch?v=1grtWKqTn50 (우아한테크)




# 동시성, 병렬성

## 동시성

- 하나의 코어에서 하나 이상의 프로세스 or 쓰레드가 번갈아가면서 진행되지만 동시에 진행되는거처럼 보이게 하는 현상
- 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로, 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질을 말한다.

## 병렬성

- 둘 이상의 코어에서 하나 이상의 프로세스 or 쓰레드가 한꺼번에 진행되는 것을 의미한다.
- 멀티 코어에서 멀티 스레드를 동작시키는 방식으로, 한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질을 말한다.

참고 : https://vagabond95.me/posts/concurrency_vs_parallelism/



# race condition(경쟁 조건)이란?

- 여러 프로세스/쓰레드가 같은 데이터를 조작할 때 타이밍이나 접근순서에 따라 결과가 달라질 수 있는 것을 의미한다.

# synchronization(동기화)이란?

- 여러 프로세스/쓰레드를 동시에 실행을 해도 공유데이터의 일관성을 유지하는 것을 말한다.

# critical section(임계 영역)이란?

- 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/쓰레드만 진입해서 실행 가능한 영역이다.

# mutual exclusion이란?

- 하나의 프로세스/쓰레드만 진입해서 실행

## mutual exclusion을 보장하는 방법

- 락을 사용

### 락을 사용하는 방법

- TestAndSet을 사용한다.

### TestAndSet()의 특징

- cpu의 atomic 명령어로 cpu의 도움을 받는다.

### atomic 명령어의 특징

- 따라서 실행 중간에 간섭받거나 중단되지 않는다.
- 같은 메모리 영역에 동시에 실행되지 않는다.


# spinLock이란?

- 락을 가질 수 있을 때까지 반복해서 시도 것을 의미한다.

## 단점

- 기다리는 동안 cpu를 낭비하게 된다.(락이 있는지 확인하는 과정 자체가 cpu의 사이클을 사용하기 때문이다.


# mutex란?

- 락을 가질 수 있을 때까지 휴식하는 상태

## 특징
- mutex 안에 변수 value를 이용해서 락을 취득하고 해제함으로써 critical section에 접근한다.
- value 값을 가질 수 없을 때는 큐에서 대기를 하다가 락을 취득할 수 있을 때 깨운다. (공중화장실이 1개 일 경우 누군가 사용하고 있다면 밖에서 줄 서서 기다려야 한다.)
- mutex 안에 변수 guard를 이용해서 race condition이 일어나는 것을 방지하는 안전장치이다.
- cpu 레벨에서 지원하는 atomic한 명령어를 사용하고 있다.

## mutex가 항상 spinLock보다 항상 좋은 것일까?

- 아니다. 멀티 코어의 환경일 때 critical section에서의 작업이 context switching에서의 작업보다 빨리 끝날 경우 spinLock을 사용하는 것이 좋다.
- 부연설명 : 
1. mutex에서 잠들고 깰 때 context switching이 발생한다.
2. 싱글 코어에서일 때는 spinLock의 장점이 없다. 왜냐하면 싱글코어이면 cpu가 하나이기 때문에 락을 얻기 위해서는 context switching이 발생할 수 밖에 없기 떄문이다.


# semaphore(세마포어)란 무엇일까?

- signal mechanism을 가진 하나 이상의 프로세스/쓰레드가 critical section에 접근하도록 하는 장치
- mutex와 다르게 critical section에 하나 이상 들어갈 수 있다. (공중화장실이 n개 라면 n개까지는 사람이 들어갈 수 있다. n개의 자리가 꽉차면 기다려야 한다.)
- value가 1일시 이진세마포 or 바이너리 세마포라고 불린다.
- value가 2이상일시 카운팅세마포라고 부른다.
- 순서를 정해줄 때 사용

## mutex와 binary semaphore는 같은 것 아닐까?

- 아니다. 
1. mutex는 락을 가진 프로세스/쓰레드만 락을 해제할 수 있다. semaphore는 누구나 락을 해체할 수 있다.
2. mutex는 priority inheritance라는 속성이 있고 semaphore는 그러한 특성이 없다.

참고 : https://www.youtube.com/watch?v=gTkvX2Awj6g

# blocking이란?

- 자신의 작업을 진행하다가 다른 주체의 작업이 진행되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 하는 것을 의미한다.
- ex) 직원이 blocking 상사에게 어떤 서류를 제출했을 때 blocking 상사가 서류 다 있을 때까지 옆에서 기다려라고 한다. blocking 상사가 서류를 읽는 동안은 자신의 작업을 할 수 없고 blocking 상사가 서류를 다 읽고 나서 자리로 돌아가보라고 해야 그 때부터 자신의 작업을 할 수 있다.

# non- blocking이란?

- 다른 주체의 작업과 상관없이 자신의 작업을 하는 것을 의미한다.
- ex) 직원이 non-blocking 상사에게 서류를 제출했을 때 non-blocking상사가 서류 읽어볼테니 가서 하던거 하세요라고 말한다. 직원은 자신의 작업을 바로 할 수 있게 된다.

## blocking vs non-blocking

- 다른 주체가 작업 할 때 자신의 제어권이 있는지 없는지로 판단 할 수 있다.


# synchronous란?

- 작업을 끝나는 동시에 시작하는 것을 의미한다.
- ex) 직원이 synchronous 상사에게 서류를 제출했을 때 상사는 직원이 작업을 하든 옆에 있든 신경쓰지 않고 서류를 읽는다. 서류를 읽고 나서 결과가 나오면 직원에게 알려주고 직원은 결과가 나오자마자 결과를 바탕으로 자신의 작업을 한다.


# asynchronous란?

- 작업을 끝나는 동시에 시작하지 않는 것을 의미한다.
- ex) 직원이 asynchronous 상사에게 서류를 제출했을 때 상사는 직원이 작업을 하든 옆에 있는 신경쓰지 않고 서류를 읽는다. 서류를 읽고 나서 결과가 나오면 직원에게 알려주고 직원은 결과를 받고나서 자신이 작업을 하고 싶을 때한다.


## synchronous vs asynchronous

- 결과를 돌려주었을 때 결과와 순서에 관심이 있는지 아닌지로 구별할 수 있다.


# blocking - synchronous

- 자신의 작업을 하다가 다른 주체의 작업이 시작되면 기다렸다가 결과가 나오면 즉시 자신의 작업을 하는 것을 의미한다.
- ex) 직원이 block-synchronous라는 상사에게 서류를 제출했을 때 상사가 서류를 읽을 때까지 옆에서 기다리라고 한다. 상사가 서류를 다 읽고 결과를 직원에게 주면 직원은 바로 자신의 작업을 진행하게 된다.
- ex) 자바의 입력

# non-blocking - synchronous

- 자신의 작업을 하다가 다른 주체의 작업이 시작되도 자신의 작업을 계속한다. 결과가 나왔는지 중간에 체크를 하고 결과가 아직 나오지 않으면 자신의 작업을 하고 결과가 나오면 결과를 받아와서 작업을 한다.
- ex) 직원이 non-blocking - synchronous라는 상사에게 서류를 제출한다. 상사는 서류를 읽는동안 직원이 작업을 하든 옆에 있든 신경쓰지 않는다. 직원은 작업을 하다가 중간에 결과가 나왔는지 상사에게 물어본다. 결과가 아직 안나왔을 경우 자신의 작업을 하러 다시 가고 결과가 나오면 결과를 받아와서 즉시 작업을 진행한다.


# blocking - asynchronous

- 자신의 작업을 하다가 다른 주체의 작업이 시작되면 기다렸다가 결과가 나와도 자신이 작업을 하고 싶을 때 하는 것을 의미한다.
- ex) 직원이 blocking - asynchronous라는 상사에게 서류를 제출한다. 상사는 서류를 읽을 동안 직원에게 옆에서 기다리라고 한다. 결과가 나오면 직원의 작업을 하고 자신이 하고 싶을 때 서류의 결과에 대한 작업을 한다.

# non-blocking - asynchronous

- 자신의 작업을 하다가 다른 주체의 작업이 시작되어도 자신의 작업을 계속한다. 결과가 나와도 자신이 하던 작업을 마친 후 자신이 하고 싶을 때 결과에 대한 작업을 진행한다.
- ex) 직원이 non-blocking - asynchronous라는 상사에게 서류를 제출한다. 상사는 서류를 읽을 때 직원이 뭘하든지 관심이 없다. 직원은 상사가 서류를 읽는 동안 자신의 작업을 한다. 결과가 나오고 직원은 자신의 작업을 마저하다가 하고 싶을 때 결과에 대한 작업을 진행한다.


참고 : https://www.youtube.com/watch?v=oEIoqGd-Sns


# 데드락이란?

- 둘 이상의 프로세스/쓰레드가 한정된 자원을 얻지 못해 다음 처리를 진행하지 못하는 상태를 의미한다.

## 데드락의 발생조건

1. 상호 배제(mutual exclusion)
2. 점유 대기(hold and wait)
3. 비선점(no preemption)
4. 순환 대기(circular wait)

- 위의 네가지를 모두 만족하면 교착 상태가 발생하게 된다.

## 데드락의 해결방안

1. 교착 상태 예방
- 네 가지 발생조건 중 하나를 제거하여 해결하는 방법
- 자원 사용 효율성이 떨어지고 비용이 많으 드는 방법
- 1) 상호 배제 (Mutual exclusion) 부정 : 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다.
- 2) 점유 대기 (Hold and wait) 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.
- 3) 비선점 (No preemption) 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.
- 4) 순환 대기 (Circular wait) 부정 : 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

2. 교착 상태 회피
-  교착 상태가 발생하면 피해나가는 방법

3. 교착 상태 탐지 및 회복
- 교착 상태가 되도록 허용한 다음에 회복시키는 방법

4. 교착 상태 무시
- 대부분의 시스템은 교착 상태가 잘 발생하지 않으며, 교착 상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

출처: https://jwprogramming.tistory.com/12 [개발자를 꿈꾸는 프로그래머:티스토리]


# 캐시란? 









