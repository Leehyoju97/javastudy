## stateless(무상태 프로토콜)

- 서버가 클라이언트의 상태를 보존하지 않는 것을 의미한다.

### 무상태를 언제 사용하면 좋을까?

1. 서버 장애 발생시 피해가 큰 경우

2. 수강신청, 선착순 이벤트와 같이 같은 시간에 많은 트래픽이 발생하는 경우

## stateful(상태유지 프로토콜)

- 서버가 클라이언트의 상태를 보존하는 것을 의미한다.

### 상태유지를 언제 사용하면 좋을까?

- 로그인 상태를 유지해야 하는 경우

## 스케일업, 스케일아웃

### 스케일업(수직 스케일링)

- 기존 서버를 높은 사양으로 업그레이드 하는 것을 말한다.
- 하드웨어 장비의 성능을 높임
- 수직 확장이며, 성능 확장에 한계가 있다.
- 성능 증가시 비용이 높다.
- 한 대의 서버에  부하가 집중된다.

### 스케일아웃(수평 스케일링)

- 장비를 추가해서 확장하는 방식
- 하나의 장비가 처리하던 일을 여러 장비가 나누어 처리
- 수평 확장이며, 지속적 확장이 가능
- 비교적 저렴하다.


참고 : https://tecoble.techcourse.co.kr/post/2021-10-12-scale-up-scale-out/

### 스케일아웃 원리

#### 로드 밸런싱

- 트래픽을 여러대의 서버로 분산해주는 기술
- 클라이언트와 서버풀 사이에 위치

#### 로드 벨런싱 알고리즘 종류

1. 라운드로빈 방식 : 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식으로 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버가 동일한 스펙을 갖고, 서버와의 연결(세션)이 오래 지속되지 않는 경우에 적합하다.

2. 가중 라운드로빈 방식 : 각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트의 요청을 우선적으로 배분하는 방식으로 서버의 트래픽 처리 능력이 상이한 경우 사용

3. IP 해시 방식 : 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식으로 사용자의 IP를 해싱해 로드를 분배하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장

4. 최소 연결 방식 : 요청이 들어온 시점에 가장 적은 연결상태로 보이는 서버에 우선적으로 트래픽을 배분하는 방식으로 자주 세션이 길어지거나, 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합

5. 최소 리스폰타임 : 서버의 현재 연결 상태와 응답시간을 모두 고려하여 트래픽을 배문하는 방식으로 가장 적은 연결 상태와 가장 짧은 응답시간을 보이는 서버에 우선적으로 로드를 배분하는 방식이다.

6. L4(Layer 4) 로드밸런싱 : 전송 계층에서 로드를 분산하고 TCP, UDP 포트 정보를 바탕으로 하고 데이터 안을 보지 않고 패킷 레벨에서만 로드를 분산하기 때문에 속도가 빠르고 효율이 높음

7. L7(Layer 7) 로드밸런싱 : 애플리케이션 계층에서 로드를 분산하고 패킷 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분해하므로 섬세한 라우팅이 가능하여 비정상적인 트래픽을 필터링 할 수 있다. L4보다 비용이 많이 든다.(패킷의 내용을 복호화 해야하기 때문)

## 비연결성

- HTTP에서는 실제로 요청을 주고 받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 끊는다.


## TCP는 연결성, HTTP는 비연결성인 이유

- TCP는 데이터의 손실, 순서가 바뀌어을 경우 데이터를 다시 요청하여 신뢰성 있는 데이터를 받기 위해서
- HTTP는 요청이 있을 때만 연결을 유지하고 나머지는 연결을 유지하지 않음으로서 자원을 효율적으로 사용하기 위해서

## http(HyperText Transport Protocol)

- 하이퍼텍스트(HyperText)를 전송(Transfer)하기 위해 사용되는 통신 규약(Protocol)이다

## https(HyperText Transport Protocol Secure)

- http + ssl(Secure Socket Layer)
- 클라이언트가 서버로 보내는 정보를 암호화하여 제 3자가 볼 수 없도록 한다.
- 접속한 사이트가 믿을만한 사이트인지 확인해준다.

### https의 과정

1. CA에 SSL 인증서 등록 과정

- https 형식인 사이트에서 CA로 공개키방식(비대칭키방식)을 활용해 서버의 공개키, 서버의 데이터를 보낸다. 
- CA에서 검증을 통과하면 서버의 공개키, 서버의 데이터를 공개키방식으로 암호화하여 인증서를 발급하고 서버에 인증서를 보내고 클라이언트에는 CA의 공개키를 저장합니다.

2. handshack과정

- 클라이언트에서는 서버가 신뢰할 수 있는 사이트인지 모르기 때문에 서버로 부터 인증서를 요청합니다.
- 클라이언트는 인증서를 받고 CA의 공개키를 통해 복호화를 진행해서 복호화가 되면 신뢰할 수 있는 사이트라는 것을 알 수 있습니다.(인증서는 CA의 개인키로 암호화하였기 때문에 CA의 공개키로만 복호화가 가능하다)
- 인증서안에는 서버의 공개키가 저장되어 있는데 클라이언트의 대칭키(개인키)를 서버의 공개키로 암호화하여 서버로 전달합니다.
- 서버에서는 서버의 개인키로 복호화하여 클라이언트의 대칭키(개인키)를 갖게 된다.
- 클라이언트의 대칭키(개인키)에서 세션키를 생성하고 대칭방식으로 암호된 데이터를 클라이언트와 서버가 송수신한다.

## TLS(Transport Layer Security)

- SSL이 최신버전으로 변경되면서 이름이 변경되었다. (아직까지 SSL과 TLS를 혼용해서 사용해서 같다고 본다)
- 위에 hansshake과정은 TLS 과정을 통해 진행된다.

1. 인증 : 상대 사이트에 대한 신뢰성 인증
2.  암호화 : 다양한 암호화 알고리즘을 이용하여 메시지 암호화
3.  무결성 : 송/수신 메시지에 대한 Checksum기능, 변조 방지


## KeepAlive

- http는 비연결성의 특징을 가지고 있어 연결을 유지하지 않는데 http header에 KeepAlive를 시간, 요청수를 전달하여 http 연결이 끊어지지 않도록 해준다.

## Http Verson별 정리

1. http/0.9
- 헤더 없이 html파일만 전송 가능
- get메소드만 사용가능하고 상태 코드가 없다.

2. http/1.0
- 1.0 이라는 버전정보가 전송되고 상태코드가 응답의 시작 부분에 붙어 전송된다.
- 헤더 개념이 요청과 응답에 모두 도입되고 html파일 이외에 다른 문서들을 전송할 수 있게 되었다.

3. http/1.1
- persist connection을 사용해서 timeout동안 커넥션을 닫지 않도록 하는 방식을 사용
- 파이프라이닝을 사용해 하나의 커넥션에서 응답을 기다리지 않고 여러 요청을 보낸후 순서에 맞춰 응답을 받는 형식으로 지연 시간을 줄임

4. http/2.0
- 1.1에서 여러 요청이 보냈졌을 때 http 헤더도 중복되어 보내지게 되었는데 이러한 문제점을 해결하기 위해 http 헤더의 중복되어진 부분을 찾아 허프만 인코딩 방식으로 압축한다.
- http 메시지 전송 방식을 텍스트가 아닌 바이너리 방식으로 변경(파싱, 전송 속도 향샹, 오류 감소)
- 1.1버전에서 head of locking이라는 문제점이 있었는데 응답 다중화(request and response multiplexing)를 통해 해결(각 stream에서 요청 순서와 관계없이 frame을 조합하므로 요청 순서대로 응답을 보낼 필요가 사라진다)
- stream prioritization : 우선순위 설정 가능
- 서버가 클라이언트의 요청과 관계없이, 단일 클라이언트에게 리소스를 전송할 수 있다.(예를 들어 클라이언트가 html파일을 요청을 했는데 서버가 생각했을 떄 css, js파일이 당연히 필요할 경우 같이 응답에 담아 클라이언트에게 넘겨준다.)

5. http/3.0
- 이전의 버전은 tcp기반이었지만 3.0버전부터는 udp기반으로 하는 quic(quick udp internet connection)을 사용


## 쿠키
- 클라이언트에 저장되는 데이터 파일이다. 페이지 요청시 서버에서 쿠키를 생성하여 HTTP 헤더를 담아 응답한다. 클라이언트에서는 이 쿠키를 갖고 있다가 요청할때마다 HTTP헤더에 담아 요청한다.

- 유효시간은 set-cookie: max-age에서 초단위로 설정하거나 expires로 날짜로 설정할 수 있다.
- 쿠키 사용 예 : 배너광고, 팝업창, 장바구니, 자동로그인

## 세션

- 일정 시간(브라우저가 종료되는 시점)동안 서버와 클라이언트간 연결을 유지시키는 기술 인데 이때 페이지 요청시 서버에서 세션아이디를 발급하여 사용자의 정보를 서버에 저장한 후 쿠키에 세션아이디를 담아 클라이언트를 구분짓는다.
- 세션 사용 예: 화면 이동시 로그인 상태 유지, 관리자/사용자 여부 판단

### 세션 아이디

- 세션 식별자로서 사용자를 식별하고 사용자가 사용하는 특정 정보를 가질 수 있도록 사용하는 것이다.






